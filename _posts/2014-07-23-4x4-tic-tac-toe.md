---
layout: post
title: 4x4 Tic Tac Toe
---

I finished the 4x4 Tic Tac Toe implementation. In the end the changes needed were simple, but getting to these changes took more time than I anticipated.

In order to have the Negamax algorithm return a move in a reasonable amount of time &ndash; the acceptance criteria was < 3 seconds &ndash; some adjustments to the existing implementation were needed. It’s okay to calculate every possible board constellations when playing a 3x3 board (which is 9! for the first move). But going through all 16! possible moves on a 4x4 is neither really possible, nor feasible, with the current hardware.

So in order to speed up the implementation a bit, I figured that for the first 5 moves on the board, it’s irrelevant which locations the computer player chooses. Since the real &ldquo;need&rdquo; to block a possible winning move of the player, he needs to have at least 3 marks set in one row. So 3 marks for player one and 2 marks for player two (since they mark the board in turns). Now, up to 5 moves on the board, the computer player just pics a random free location (e.g. `board.free_locations.sample`).

Only after at least 5 moves the locations will be based on Negamax. Which leads to the seconds optimisation. There is also no real need to calculate _all_ possible boards &ndash; just _enough_ is sufficient. So currently the lookup for the &ldquo;next best move&rdquo; will only go deep 5 levels of recursion. That _should_ be sufficient to have a reasonable move available. With only 4 levels I still could win, so increasing the level  by one made the trick.

After I was done with this storit, I started with my Qt spike on the Coin Changer application. I have a very basic UI working for that, and I have to admit that I didn’t expect I would be this fast with it. I thought getting Qt up and running would take more time. So tomorrow I can re-estimate my initial story for the Qt GUI for Tic Tac Toe.
